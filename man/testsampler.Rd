% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/testsampler.R
\name{testsampler}
\alias{testsampler}
\title{Implement stratified sampling}
\usage{
testsampler(
  data,
  stratifying,
  N_sample,
  na.rm = "stop",
  allocation = "optimal",
  threshold = 0.5,
  N_bins_left = 5,
  N_bins_right = 5,
  seed = 1234,
  min_per_bin = 1,
  manual_allocation = NULL,
  pi1 = NULL,
  pi0 = NULL,
  trained_model = NULL,
  recall = NULL,
  external_k = NULL,
  external_positive_share = NULL,
  n_positive = NULL,
  weight_se_f1 = 1,
  weight_se_rec = 0,
  weight_se_prec = 0
)
}
\arguments{
\item{data}{A data.frame from which to sample observations. One column should
contain the stratifying variable used to construct the strata for sampling.}

\item{stratifying}{A character value capturing the column name of the stratifying
variable. This column should contain continuous numeric values between 0 and 1
(predicted probability of exhibiting the outcome).}

\item{N_sample}{A numeric value capturing the desired sample size.}

\item{na.rm}{A character value indicating how to deal with NA values in the
stratifying variable (indicated by `stratifying`). Options include: 'drop'
(this drops observations with NA in the stratifying variable), 'stop' (this
ensures the function stops running if there are any NAs in the stratifying variable)
and 'impute' (this median-imputes the NAs in the stratifying variable). Default
is 'stop'. Users can manually create a bin for NAs before using the function
if they so wish, by turning the stratifying variable into a character or factor
variable and encoding missing values with one category (e.g. 'NA').}

\item{allocation}{A character value capturing the type of allocation regime used
for stratified sampling. Options include: 'constant', 'proportional', 'optimal'
and 'manual'. If set to 'constant', the function calls \code{\link{constant_allocation}},
and implements constant allocation, aiming for all strata to get the same number
of observations in the test set. If set to 'proportional', the function calls
\code{\link{proportional_allocation}}, and implements proportional allocation,
aiming for each stratum to get a proportional number of observations in the test
set relative to the stratum's number of observations in the population. If set to
'optimal', the function attempts to call \code{\link{optimal_allocation}} (only
if parameter values support this), and implements efficient two-bin allocation,
determining how many positives and negatives to optimally sample (or taking this
from the user-provided `n_positive`) and then performing proportional allocation
in each stratum. If set to 'manual', the function samples as many observations per
bin as indicated in the `manual_allocation` argument.}

\item{threshold}{A numeric value capturing the threshold for binary classification.}

\item{N_bins_left}{A numeric value capturing how many bins there should between
zero and `threshold` (closed and open respectively).}

\item{N_bins_right}{A numeric value capturing how many bins there should between
`threshold` and 1 (both closed).}

\item{seed}{A numeric value that sets seed internally for sampling.}

\item{min_per_bin}{A numeric value capturing the minimum number of observations per bin.
Default is 1.}

\item{manual_allocation}{A named vector, whose elements are numeric, and whose
names correspond to unique strata. This vector indicates how many observations to
sample, allowing the user to specify a specific custom stratified allocation.
This argument should only be provided when argument `allocation` is set to 'manual'.}

\item{pi1}{A numeric value capturing the expected precision (share of cases
exhibiting the outcome out of predicted positives). This value is then used to
determine what the optimal allocation is. This argument only must be entered if
`allocation` is set to 'optimal' and no `caret` model object is provided in
`trained_model`.}

\item{pi0}{A numeric value capturing the inverse of the expected precision for
the negative class (share of cases exhibiting the outcome out of predicted
negatives). This value is then used to determine what the optimal allocation is.
This argument only must be entered if `allocation` is set to 'optimal' and no
`caret` model object is provided in `trained_model` and `recall` is not entered.}

\item{trained_model}{A `caret` model object, used to estimate `pi1` and `pi0` if
these are not manually provided, and if simultaneously `allocation` is set to
'allocation'. The model can only be used if cross validation was used during
training: then, excluded folds are used to guess `pi1` and `pi0`.}

\item{recall}{A numeric value capturing the expected value of recall (share of
positive cases among those exhibiting the outcome). This value only needs to be
entered if `pi0` is left blank. This argument only must be entered if `allocation`
is set to 'optimal' and no `caret` model object is provided in `trained_model`
and `pi0` is not entered.}

\item{external_k}{A numeric value capturing the imbalance ratio (number of predicted
positives over predicted negatives) in the population on which the recall estimate
is based. This only needs to be entered if `recall` is based on a population
that has a different imbalance than the test's population. The argument is
only required if `pi0` is not entered directly and no `caret` model object is
provided in `trained_model` and `external_positive_share` is not entered, while
allocation is set to 'optimal'.}

\item{external_positive_share}{A numeric value capturing the positive share
(number of predicted positives out of all observations) in the population on
which the recall estimate is based. This only needs to be entered if `recall`
is based on a population that has a different imbalance than the test's population.
The argument is only required if `pi0` is not entered directly and no `caret`
model object is provided in `trained_model` and `external_k` is not entered,
while allocation is set to 'optimal'.}

\item{n_positive}{A numeric value indicating how many positive observations to
include in the stratified sample. Positives and negatives are then sampled
separately using stratified sampling with proportional allocation in the positive
and negative subsamples respectively. Note `n_positive` should be an integer,
and it should only be entered if `allocation` is set to 'optimal'.}

\item{weight_se_f1}{A numeric value between 0 and 1 capturing how much to weigh
the SE for the F1 score in the objective function to be minimized for optimal
allocation (see details in \code{\link{optimal_allocation}}). The default
for `weight_se_f1` is `1`. This should only be entered if `allocation` is set
to 'optimal'.}

\item{weight_se_rec}{A numeric value between 0 and 1 capturing how much to weigh
the SE for recall in the objective function to be minimized for optimal
allocation (see details in \code{\link{optimal_allocation}}). The default for
`weight_se_rec` is `0`. This should only be entered if `allocation` is set to
'optimal'.}

\item{weight_se_prec}{A numeric value between 0 and 1 capturing how much to
weigh the SE for precision in the objective function to be minimized for
optimal allocation (see details in \code{\link{optimal_allocation}}). The
default for `weight_se_prec` is `0`. This should only be entered if `allocation`
is set to 'optimal'.}
}
\value{
A data.frame object that contains the test set sample to be annotated.
This data.frame contains same columns as the original data.frame inputted in the
`data` argument, but contains fewer rows since it is just a sample. Additionally it
contains the following column: `stratifying` (numeric or character variable with
the values of the stratifying variable), `id_sampling` (variable indicating which
rows were included in the sample), `strata` (character variable indicating what
stratum each sampled observation belongs to), and `Prob` (numeric variable
indicating the sampling probability for any given observation in the test sample).
}
\description{
This function implements stratified sampling under constant, proportional or optimal allocation
}
\details{
This function can be used to implement the sampling process. It take as input the
dataset from which to sample and produces a smaller sampled dataset as output, i.e.
the test set. The function supports stratified sampling with constant allocation
across bins, proportional allocation, optimal two-bin allocation (with the
optimal number of positives for minimizing some linear combination of the SEs of
precision, recall and F1 score), and custom allocation to be manually inputed.
The function also allows users to flexibly select binning strategy, by specifying
how many bins they want to each side of the predicted probability threshold.
If users want to stratify on the basis of some variable other than the predicted
probability, they can construct the bins manually before using the function and
then enter a character variable as `stratifying` (this supports all types of
allocation except optimal). The output dataset contains the same columns as the
input plus: sampling indices, strata bins, and sampling probabilities which will
be used after annotation for constructing stratified estimates of performance metrics.
}
\examples{
## example 1: draw a test set of 1000 observations, by stratified sampling on
## predicted probability bins, with 6 bins left of 0.4 threshold and 5 bins right
## of this threshold with constant allocation.
data(pop_df)
out <- testsampler(data=pop_df, stratifying='score', N_sample=1000, allocation='constant',
                   threshold=0.4, N_bins_left=6, N_bins_right=5)
## example 2: draw a test set of 1000 observations, by stratified sampling on
## predicted probability bins, with 6 bins left of 0.4 threshold and 5 bins right
## of this threshold with proportional allocation.
data(pop_df)
out <- testsampler(data=pop_df, stratifying='score', N_sample=1000, allocation='proportional',
                   threshold=0.4, N_bins_left=6, N_bins_right=5)
## example 3: draw a test set of 1000 observations, by stratified sampling on
## predicted probability bins, with 6 bins left of 0.4 threshold and 5 bins right
## of this threshold with optimal allocation. first, number of positives and negatives
## is determined first, and then optimal allocation within each bin. assume we're
## minimizing the objective function SE(F1) + 0.5 SE(precision) + 0.5 SE(recall).
## as assumptions, we have guesses for pi1 (TP/TP+FP) and pi0 (FN/FN+TN) of 0.4 and 0.02.
data(pop_df)
out <- testsampler(data=pop_df, stratifying='score', N_sample=1000, threshold=0.4,
                   N_bins_left=6, N_bins_right=5, pi1=0.4, pi0=0.2, weight_se_f1=1,
                   weight_se_rec=0.5, weight_se_prec=0.5)
## example 4: like example 3, but instead we only care about the SE of the f1.
## Plus, we want simple two-bin positive-negative stratification (0.4 threshold).
data(pop_df)
out <- testsampler(data=pop_df, stratifying='score', N_sample=1000, threshold=0.4,
                   N_bins_left=1, N_bins_right=1, pi1=0.4, pi0=0.2, weight_se_f1=1,
                   weight_se_rec=0, weight_se_prec=0)
## example 5: like example 3, but assuming we know recall was 0.6 in some other
## dataset where the imbalance ratio had 1 positive for every 2 negatives so
## external_k is 1/2=0.5
data(pop_df)
out <- testsampler(data=pop_df, stratifying='score', N_sample=1000, threshold=0.4,
                   N_bins_left=6, N_bins_right=5, pi1=0.4, recall=0.6, external_k=0.5,
                   weight_se_f1=1, weight_se_rec=0.5, weight_se_prec=0.5)
## example 6: we decide manually how many positives and negatives to sample (500
## each) and then sample with proportional allocation with the positive and negative
## strata (5 bins in each).
data(pop_df)
out <- testsampler(data=pop_df, stratifying='score', N_sample=1000, threshold=0.4,
                   N_bins_left=5, N_bins_right=5, n_positive=500)
## example 7: like example 1, we use constant allocation stratification, but on
## some non-numeric categorical variable. therefore, no threshold needed
data(pop_df)
pop_df$somevar <- as.character(rbinom(nrow(pop_df), 2, 0.4)) #create random stratifying variable
out <- testsampler(data=pop_df, stratifying='somevar', allocation='constant',
                   N_sample=1000, N_bins_left=6, N_bins_right=5)
## example 8: like example 7, we stratify the sampling on some custom categorical variable
## but also specify a custom allocation
data(pop_df)
pop_df$somevar <- as.character(rbinom(nrow(pop_df), 2, 0.4)) #create random stratifying variable
custom <- c(200, 200, 600)
names(custom) <- c("0", "1", "2")
out <- testsampler(data=pop_df, stratifying='somevar', allocation='manual',
                   N_sample=1000, manual_allocation=custom)
}
