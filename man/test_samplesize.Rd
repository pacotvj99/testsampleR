% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/test_samplesize.R
\name{test_samplesize}
\alias{test_samplesize}
\title{Sample size calculator}
\usage{
test_samplesize(
  se_f1 = NULL,
  se_precision = NULL,
  se_recall = NULL,
  max_N = NULL,
  min_N = 1,
  by_N = 1,
  pi1 = NULL,
  pi0 = NULL,
  recall = NULL,
  k = NULL,
  positive_share = NULL,
  external_k = NULL,
  external_positive_share = NULL,
  weight_se_f1 = 1,
  weight_se_prec = 1,
  weight_se_rec = 1
)
}
\arguments{
\item{se_f1}{A numeric value capturing the desired standard error for the F1
score of the positive class. If non-numeric, then the sample size calculation
ignores the SE of F1. The sample size calculator selects a sample size such that
the SE of the F1 score is below `se_f1`.}

\item{se_precision}{A numeric value capturing the desired standard error for
precision of the positive class. If non-numeric, then the sample size calculation
ignores the SE of precision. The sample size calculator selects a sample size
such that the SE of precision is below `se_precision`.}

\item{se_recall}{A numeric value capturing the desired standard error for
recall of the positive class. If non-numeric, then the sample size calculation
ignores the SE of recall. The sample size calculator selects a sample size such
that the SE of recall is below `se_recall`.}

\item{max_N}{A numeric value capturing the maximum sample size to be considered.}

\item{min_N}{A numeric value capturing the minimum sample size to be considered.
Default is `1`.}

\item{by_N}{A numeric value capturing the size of the intervals between `min_N`
and `max_N` to be considered as possible sample sizes. Default is `1`.}

\item{pi1}{A numeric value capturing the expected precision (share of cases
exhibiting the outcome out of predicted positives). This value must be entered
for the function to produce an output.}

\item{pi0}{A numeric value capturing the inverse of the expected precision for
the negative class (share of cases exhibiting the outcome out of predicted
negatives). If left blank, the function computes `pi0` from recall and imbalance
if `pi0` is not explicitly entered. Note this value need not be entered if
`se_recall` and `se_f1` are left blank.}

\item{recall}{A numeric value capturing the expected value of recall (share of
positive cases among those exhibiting the outcome). This value only needs to be
entered if `se_recall` or `se_f1` are specified but `pi0` is left blank.}

\item{k}{A numeric value capturing the imbalance ratio (number of predicted positives
over predicted negatives) in the population from which the test set should be
drawn. Argument `k` can be left blank, but then `positive_share` must be specified.}

\item{positive_share}{A numeric value capturing the positive share (number of
predicted positives out of all observations) in the population from which the
test set should be drawn. Argument `positive_share` can be left blank, but
then `k` must specified.}

\item{external_k}{A numeric value capturing the imbalance ratio (number of predicted
positives over predicted negatives) in the population on which the recall estimate
is based. This only needs to be entered if `recall` is based on a population
that has a different imbalance than the test's population. The argument is
only required if `pi0` is not entered directly. If left blank, it will be
calculated internally using `external_positive_share`, if this is entered, or
assumed to be equal to the test population's imbalance `k`.}

\item{external_positive_share}{A numeric value capturing the positive share
(number of predicted positives out of all observations) in the population on
which the recall estimate is based. This only needs to be entered if `recall`
is based on a population that has a different imbalance than the test's population.
The argument is only required if `pi0` is not entered directly. If left blank,
it will be calculated internally using `external_positive_share`, if this is
entered, or assumed to be equal to the test population's imbalance.}

\item{weight_se_f1}{A numeric value between 0 and 1 capturing how much to weigh
the SE for the F1 score. This only applies when there are multiple values of
`n_positive` that verify the desired SE conditions for a given sample size under
stratified sampling. When this happens, the value of `n_positive` is selected by
picking the number that minimizes the sum of the SE for F1 score, precision and
recall, weighted by `weight_se_f1`, `weight_se_precision` and , `weight_se_recall`.
The default for `weight_se_f1` is `1`.}

\item{weight_se_prec}{A numeric value between 0 and 1 capturing how much to weigh
the SE for precision. This only applies when there are multiple values of `n_positive`
that verify the desired SE conditions for a given sample size under  stratified
sampling. When this happens, the value of `n_positive` is selected by picking
the number that minimizes the sum of the SE for F1 score, precision and recall,
weighted by `weight_se_f1`, `weight_se_prec` and , `weight_se_rec`. The default
for `weight_se_prec` is `1`.}

\item{weight_se_rec}{A numeric value between 0 and 1 capturing how much to
weigh the SE for recall. This only applies when there are multiple values of
`n_positive` that verify the desired SE conditions for a given sample size under
stratified sampling. When this happens, the value of `n_positive` is selected by
picking the number that minimizes the sum of the SE for F1 score, precision and
recall, weighted by `weight_se_f1`, `weight_se_prec` and , `weight_se_rec`. The
default for `weight_se_rec` is `1`.}
}
\value{
A list of two data.frame objects (`srs` and `stratified`), which contain the result of the power
calculation under SRS and stratified sampling respectively. These data.frames
contain the minimum number of observations (`sample_size_srs` and `sample_size_strat`)
needed to verify the desired SEs conditions (i.e. smaller than `se_f1`, `se_precision`
and `se_recall`). For stratified sampling, the output also contains how many
positive observations (`n_positives`) need to be sampled to achieve the desired SEs.
Under either sampling, the output also indicates what the SE would be for each
metric and sampling stratgy, given the selected sample size. When the maximum
sample size (`max_N`) is too small to achieve the desired SEs, the output indicates
this instead.
}
\description{
This function estimates how many observations need to be sampled to achieve a desired standard error.
}
\details{
This function can be used to estimate how many observations need to be included
in the test set under simple random sampling (SRS) or under efficient stratified
sampling. The standard errors (SEs) are based on analytic formulas for the
variance of the sampling distribution of the test set estimates of F1, precision
and recall. Such variances are based on expected parameter values, which need to
be entered by the user. Given parameter values, the function looks at what sample
sizes up to `max_N` verify that the SEs for F1, precision and recall are below
the maximum desired SE, which need to be entered by the user. Under SRS, the
function returns the minimum sample size that verifies the desired SEs conditions,
as well as the SEs under such sample size. Under stratified sampling, the function
returns the minimum sample size such that the desired SE conditions can be verified
for some allocation (i.e. some number of positives to be sampled): this is based
on two-bin stratified sampling (sampling positives and negatives separately), and
the resulting sample calculation is not valid if stratifying on some other variable.
Under stratified sampling, the function also returns how to allocate the sample
size between positives and negatives to verify the desired SEs conditions for
the given sample size. When there are multiple values of `n_positive` that
verify the desired SE conditions for a given sample size, the value of `n_positive`
is selected by picking the number that minimizes the sum of the SE for F1 score,
precision and recall, weighted by some user-provided weights.
}
\examples{
## example 1: required sample size to get SE of F1 below 3pp
## assuming we have guesses for pi1 (TP/TP+FP) and pi0 (FN/FN+TN) of 0.4 and 0.02
## assuming we know in the test set 10\% of observations are positive
## further assuming that when multiple allocations exist, we only care about F1
test_samplesize(se_f1=0.03, max_N=4000, pi1=0.4, pi0=0.02, positive_share=0.1,
               weight_se_f1=1, weight_se_prec=0, weight_se_rec=0)
## example 2: same but assuming we know test set has 1 positive for every 2
## negatives so k is 1/2=0.5
test_samplesize(se_f1=0.03, max_N=4000, pi1=0.4, pi0=0.02, k=0.5,
                weight_se_f1=1, weight_se_prec=0, weight_se_rec=0)
## example 3: now we want SE for F1 to be up to 3pp and SE for recall to be up to 5pp
## and precision's SE is below 5pp. plus, assume in case multiple allocations verify this,
## we want the allocation minimizing SE(F1)+0.5 SE(recall)+0.5 SE(precision).
## assumptions about pi1, pi0 and k are as in example 2.
test_samplesize(se_f1=0.03, se_precision=0.05, se_recall=0.05,
                max_N=4000, pi1=0.4, pi0=0.02, k=0.5,
                weight_se_f1=1, weight_se_prec=0.5, weight_se_rec=0.5)
## example 4: same as example 2 but we do not have a guess for pi0. however, we
## know the classifier had recall of 0.6 in a dataset where 20\% of observations
## were positive
test_samplesize(se_f1=0.03, max_N=4000, pi1=0.4, k=0.5,
                recall=0.6, external_positive_share=0.2,
                weight_se_f1=1, weight_se_prec=0, weight_se_rec=0)
## example 5: same as example 4 but we do not know the imbalance on the dataset
## where recall was estimated, so we assume it to be same as in our evaluation
## dataset
test_samplesize(se_f1=0.03, max_N=4000, pi1=0.4, k=0.5, recall=0.6,
                weight_se_f1=1, weight_se_prec=0, weight_se_rec=0)
## example 6: same as example 1 but we only care about precision and want
## to get its SE below 3pp. then we do not need to specify pi0, recall,
## external_k or external_positive_share
test_samplesize(se_precision=0.03, max_N=4000, pi1=0.4, k=0.5,
                weight_se_f1=0, weight_se_prec=1, weight_se_rec=0)
}
